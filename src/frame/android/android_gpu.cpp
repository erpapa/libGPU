/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_visionin_gpu_GPU */
#include "bs.h"
#include "GPU.h"
#include "GPUStreamFrame.h"

#ifdef __cplusplus
extern "C" {
#endif
void initialize(JNIEnv* env, jclass jc, jobject context, jstring jlicense);

void resource(JNIEnv* env, jclass jc, jobject asset);
jint createTexture(JNIEnv* env, jclass jc);
void destroyTexture(JNIEnv* env, jclass jc, jint ji);

jlong eglContext(JNIEnv * env, jobject jo, jboolean active);
void setRenderSurface(JNIEnv * env, jobject jo, jobject jobj);
void makeCurrent(JNIEnv * env, jobject jo, jlong jl);
void destroyEGL(JNIEnv * env, jobject jo, jlong jl);

void processTexture(JNIEnv * env, jobject jo, jint texture, jint texture_type);
void processBytes(JNIEnv* env, jobject jo, jbyteArray jb, jint w, jint h, jint format);
void getBytes(JNIEnv* env, jobject jo, jbyteArray jb);
int getTexture(JNIEnv* env, jobject jo);

void setOutputSize(JNIEnv * env, jobject jo, jint width, jint height);
void setOutputFormat(JNIEnv * env, jobject jo, jint format);

void setInputSize(JNIEnv * env, jobject jo, jint width, jint height);
void setInputRotation(JNIEnv * env, jobject jo, jint rotation);

void setPreviewMirror(JNIEnv * env, jobject jo, jboolean mirror);
void setOutputMirror(JNIEnv * env, jobject jo, jboolean mirror);
void setOutputRotation(JNIEnv * env, jobject jo, jint rotation);

void setSmoothStrength(JNIEnv * env, jobject jo, jfloat level);

void setExtraFilter(JNIEnv * env, jobject jo, jstring jname);
void closeExtraFilter(JNIEnv * env, jobject jo);
void setExtraParameter(JNIEnv * env, jobject jo, jfloat para);

void setOutputView(JNIEnv * env, jobject jo);
void removeOutputView(JNIEnv * env, jobject jo);
void setViewRotation(JNIEnv * env, jobject jo, jint rotation);
void setViewOutputSize(JNIEnv* env, jobject jo, jint width, jint height);
void setViewFillMode(JNIEnv* env, jobject jo, jint mode);

// blend用于logo
void setPreviewBlend(JNIEnv * env, jobject jo, jstring jpath, jfloat x, jfloat y, jfloat w, jfloat h, jboolean mirror);
void setVideoBlend(JNIEnv * env, jobject jo, jstring jpath, jfloat x, jfloat y, jfloat w, jfloat h, jboolean mirror);

#ifdef __cplusplus
}
#endif

static GPUTextureInput*  g_texture_input = NULL;
static GPURawInput*      g_raw_input = NULL;
static GPUView*          g_view = NULL;

// 创建Android NV21 Texture
jint createTexture(JNIEnv * env, jclass jc){
	GLuint texture;
	GPUContext::shareInstance()->makeCurrent();
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
	//glActiveTexture(GL_TEXTURE1);
	glGenTextures(1, &texture);
	//glBindTexture(GL_TEXTURE_2D, texture);
	glBindTexture(GL_TEXTURE_EXTERNAL_OES, texture);
	glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	return texture;
}

// 释放texture
void destroyTexture(JNIEnv * env, jclass jc, jint texture){
	GPUContext::shareInstance()->makeCurrent();
	glDeleteTextures(1, (GLuint*)&texture);
}

// 创建glContext
jlong eglContext(JNIEnv * env, jobject jo, jboolean active){
    bs_log_init("stdout");
	GPUContext::setContextEnable(active);
	GPUContext* context  = GPUContext::shareInstance();
	context->makeCurrent();

	GPUStreamFrame* stream = new GPUStreamFrame();
	return (jlong)context;
}

void setRenderSurface(JNIEnv * env, jobject jo, jobject jobj){
	ANativeWindow* window = ANativeWindow_fromSurface(env, jobj);
	if (window==NULL)
	{
		err_log("SurfaceWindow is NULL!");
		return;
	}
	if(g_view==NULL){
		g_view = new GPUView(window);
		GPUStreamFrame::shareInstance()->setOutputView(g_view);
	}
	else{
		g_view->setNativeWindow(window);
	}
}

void makeCurrent(JNIEnv * env, jobject jo, jlong jcontext){
	GPUContext::shareInstance()->makeCurrent();
}

void destroyEGL(JNIEnv * env, jobject jo, jlong jcontext){
	GPUContext::shareInstance()->makeCurrent();

	if (g_texture_input!=NULL)
	{
		delete g_texture_input;
		g_texture_input = NULL;
	}

	if (g_raw_input!=NULL)
	{
		delete g_raw_input;
		g_raw_input = NULL;
	}

	if (g_view!=NULL)
	{
		delete g_view;
		g_view = NULL;
	}

	GPUStreamFrame::destroyInstance();
	GPUBufferCache::destroyInstance();
	info_log("Destroy Buffer Cache Success!");
	GPUVertexBufferCache::destroyInstance();
	info_log("Destroy Vertex Cache Success!");
	// 销毁，注意这里要将静态变量改为null
	GPUContext::destroyInstance();
	info_log("Destroy Surface Success!");
}

void processTexture(JNIEnv * env, jobject jo, jint texture, jint texture_type){
	if (g_texture_input==NULL)
	{
		GPUStreamFrame* stream = GPUStreamFrame::shareInstance();
		if (stream->m_frame_width==0 || stream->m_frame_height==0)
		{
			err_log("Visionin Error: don't set videosize!");
			return;
		}
		g_texture_input = new GPUTextureInput(stream->m_frame_width, stream->m_frame_height, texture_type);
		stream->setInputFilter(g_texture_input);
	}

    GPUContext::shareInstance()->runAsyncTasks();
	g_texture_input->processTexture(texture);
}

void processBytes(JNIEnv * env, jobject jo, jbyteArray jbytes, jint width, jint height, jint format){
	jbyte* bytes = (jbyte*)env->GetPrimitiveArrayCritical(jbytes, NULL);
	if (bytes==NULL)
	{
		err_log("bytes is NULL!");
		return;
	}

	if (g_raw_input==NULL)
	{
		GPUStreamFrame* stream = GPUStreamFrame::shareInstance();
		g_raw_input = new GPURawInput();

		//stream->setInputFormat((GPUPixelFormat_t)format);
		g_raw_input->addTarget(stream);
	}

	g_raw_input->uploadBytes((GLubyte*)bytes, width, height, (gpu_pixel_format_t)format);
	env->ReleasePrimitiveArrayCritical(jbytes, bytes, 0);
}

void getBytes(JNIEnv * env, jobject jobj, jbyteArray jbytes){
	jbyte* bytes = (jbyte*)env->GetPrimitiveArrayCritical(jbytes, NULL);
	if (bytes==NULL)
	{
		err_log("bytes is NULL!");
		return;
	}

	GPUStreamFrame::shareInstance()->m_raw_output->getBuffer((unsigned char*)bytes, env->GetArrayLength(jbytes));
	env->ReleasePrimitiveArrayCritical(jbytes, bytes, 0);
}

int getTexture(JNIEnv* env, jobject jo){
	return GPUStreamFrame::shareInstance()->m_raw_output->getTexture();
}

void setOutputSize(JNIEnv * env, jobject jo, jint width, jint height){
	GPUStreamFrame::shareInstance()->setOutputSize(width, height);
}

void setOutputFormat(JNIEnv * env, jobject jo, jint format){
	GPUStreamFrame::shareInstance()->setOutputFormat((gpu_pixel_format_t)format);
}

void setInputSize(JNIEnv * env, jobject jo, jint width, jint height){
	if (g_texture_input!=NULL)
	{
		g_texture_input->setOutputSize((uint32_t)width, (uint32_t)height);
	}
	GPUStreamFrame::shareInstance()->setInputSize((uint32_t)width, (uint32_t)height);
}
void setInputRotation(JNIEnv * env, jobject jo, jint rotation){
	GPUStreamFrame::shareInstance()->setInputRotation((gpu_rotation_t)rotation);
}

void setPreviewMirror(JNIEnv * env, jobject jo, jboolean mirror){
	GPUStreamFrame::shareInstance()->setPreviewMirror(mirror);
}
void setOutputMirror(JNIEnv * env, jobject jo, jboolean mirror){
	GPUStreamFrame::shareInstance()->setOutputMirror(mirror);
}
void setOutputRotation(JNIEnv * env, jobject jo, jint rotation){
	GPUStreamFrame::shareInstance()->setOutputRotation((gpu_rotation_t)rotation);
}
void setSmoothStrength(JNIEnv * env, jobject jo, jfloat level){
	//GPUStreamFrame::shareInstance()->setSmoothStrength(level);
}

void setOutputView(JNIEnv *env, jobject obj){
	GPUStreamFrame::shareInstance()->setOutputView(g_view);
}

void removeOutputView(JNIEnv * env, jobject obj){
	GPUStreamFrame::shareInstance()->removeOutputView();
}

void setExtraFilter(JNIEnv * env, jobject obj, jstring filter){
	const char* name = env->GetStringUTFChars(filter, NULL);
    if(name == NULL || strlen(name)==0) {
        return;
    }

    GPUStreamFrame::shareInstance()->setExtraFilter(name);

	env->ReleaseStringUTFChars(filter, name);
}

void setViewRotation(JNIEnv * env, jobject jo, jint rotation){
	if (GPUStreamFrame::shareInstance()->m_view!=NULL)
	{
		GPUStreamFrame::shareInstance()->m_view->setOutputRotation((gpu_rotation_t)rotation);
	}
	else{
		err_log("Visionin View: view has not been new.");
	}
}

void setViewOutputSize(JNIEnv* env, jobject jo, jint width, jint height){
	GPUStreamFrame::shareInstance()->m_preview_blend_filter.setOutputSize(width, height);
}

void setViewFillMode(JNIEnv* env, jobject jo, jint mode){
    if(GPUStreamFrame::shareInstance()->m_view!=NULL){
        ((GPUView*)GPUStreamFrame::shareInstance()->m_view)->setFillMode((gpu_fill_mode_t)mode);
    }
}

void closeExtraFilter(JNIEnv *, jobject){
	GPUStreamFrame::shareInstance()->removeExtraFilter();
}
void setExtraParameter(JNIEnv * env, jobject obj, jfloat para){
	GPUStreamFrame::shareInstance()->setExtraParameter(para);
}

void setPreviewBlend(JNIEnv * env, jobject jo, jstring jpath, jfloat x, jfloat y, jfloat w, jfloat h, jboolean mirror){
	GPUStreamFrame* stream = GPUStreamFrame::shareInstance();
	gpu_rect_t rect;
	if (jpath==NULL){
		stream->setPreviewBlend(NULL, rect, mirror);
		return;
	}

	const char* path = env->GetStringUTFChars(jpath, NULL);
	rect.pointer.x = x;
	rect.pointer.y = y;
	rect.size.width = w;
	rect.size.height = h;
	GPUPicture* pic = new GPUPicture(path);
	stream->setPreviewBlend(pic, rect, mirror);

	env->ReleaseStringUTFChars(jpath, path);
}
void setVideoBlend(JNIEnv * env, jobject jo, jstring jpath, jfloat x, jfloat y, jfloat w, jfloat h, jboolean mirror){
	GPUStreamFrame* stream = GPUStreamFrame::shareInstance();
	gpu_rect_t rect;
	if (jpath==NULL){
		stream->setVideoBlend(NULL, rect, mirror);
		return;
	}

	const char* path = env->GetStringUTFChars(jpath, NULL);
	rect.pointer.x = x;
	rect.pointer.y = y;
	rect.size.width = w;
	rect.size.height = h;
	GPUPicture* pic = new GPUPicture(path);
	err_log("path: %s  pic: %llu", path, (unsigned long long)pic);
	stream->setVideoBlend(pic, rect, mirror);

	env->ReleaseStringUTFChars(jpath, path);
}

jint JNI_OnLoad(JavaVM *vm, void *reserved) {
	return JNI_VERSION_1_4;
}